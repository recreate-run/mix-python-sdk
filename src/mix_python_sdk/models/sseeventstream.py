"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .toolname import ToolName, ToolNameTypedDict
from mix_python_sdk.types import BaseModel, UNSET_SENTINEL
from mix_python_sdk.utils import get_discriminator
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


SSESessionDeletedEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSESessionDeletedEventDataTypedDict(TypedDict):
    session_id: str
    r"""ID of the deleted session"""
    type: str
    r"""Event type"""


class SSESessionDeletedEventData(BaseModel):
    session_id: Annotated[str, pydantic.Field(alias="sessionId")]
    r"""ID of the deleted session"""

    type: str
    r"""Event type"""


class SSESessionDeletedEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSESessionDeletedEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSESessionDeletedEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSESessionDeletedEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSESessionDeletedEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSESessionDeletedEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSESessionCreatedEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSESessionCreatedEventDataTypedDict(TypedDict):
    created_at: int
    r"""Unix timestamp when the session was created"""
    session_id: str
    r"""ID of the newly created session"""
    title: str
    r"""Title of the newly created session"""
    type: str
    r"""Event type"""


class SSESessionCreatedEventData(BaseModel):
    created_at: Annotated[int, pydantic.Field(alias="createdAt")]
    r"""Unix timestamp when the session was created"""

    session_id: Annotated[str, pydantic.Field(alias="sessionId")]
    r"""ID of the newly created session"""

    title: str
    r"""Title of the newly created session"""

    type: str
    r"""Event type"""


class SSESessionCreatedEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSESessionCreatedEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSESessionCreatedEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSESessionCreatedEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSESessionCreatedEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSESessionCreatedEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEUserMessageCreatedEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEUserMessageCreatedEventDataTypedDict(TypedDict):
    content: str
    r"""Content of the user message"""
    message_id: str
    r"""ID of the created user message"""
    type: str
    r"""User message created event type"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSEUserMessageCreatedEventData(BaseModel):
    content: str
    r"""Content of the user message"""

    message_id: Annotated[str, pydantic.Field(alias="messageId")]
    r"""ID of the created user message"""

    type: str
    r"""User message created event type"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEUserMessageCreatedEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEUserMessageCreatedEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEUserMessageCreatedEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEUserMessageCreatedEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEUserMessageCreatedEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEUserMessageCreatedEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSENotificationEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


NotificationType = Literal[
    "info",
    "warning",
    "error",
    "question",
]
r"""Type of notification"""


ResponseType = Literal[
    "acknowledge",
    "text",
    "choice",
]
r"""Expected response type from user"""


class SSENotificationEventDataTypedDict(TypedDict):
    created_at: int
    r"""Unix timestamp when notification was created"""
    id: str
    r"""Notification identifier"""
    message: str
    r"""Notification message content"""
    notification_type: NotificationType
    r"""Type of notification"""
    response_type: ResponseType
    r"""Expected response type from user"""
    session_id: str
    r"""Session identifier for the notification"""
    timeout: int
    r"""Timeout in seconds for user response"""
    title: str
    r"""Notification title"""
    type: str
    r"""Notification event type"""
    choices: NotRequired[List[str]]
    r"""Available choices (required when responseType is 'choice')"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSENotificationEventData(BaseModel):
    created_at: Annotated[int, pydantic.Field(alias="createdAt")]
    r"""Unix timestamp when notification was created"""

    id: str
    r"""Notification identifier"""

    message: str
    r"""Notification message content"""

    notification_type: Annotated[
        NotificationType, pydantic.Field(alias="notificationType")
    ]
    r"""Type of notification"""

    response_type: Annotated[ResponseType, pydantic.Field(alias="responseType")]
    r"""Expected response type from user"""

    session_id: Annotated[str, pydantic.Field(alias="sessionId")]
    r"""Session identifier for the notification"""

    timeout: int
    r"""Timeout in seconds for user response"""

    title: str
    r"""Notification title"""

    type: str
    r"""Notification event type"""

    choices: Optional[List[str]] = None
    r"""Available choices (required when responseType is 'choice')"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["choices", "parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSENotificationEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSENotificationEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSENotificationEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSENotificationEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSENotificationEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSENotificationEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEPermissionEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class ParamsTypedDict(TypedDict):
    r"""Additional parameters for the permission request"""


class Params(BaseModel):
    r"""Additional parameters for the permission request"""


class SSEPermissionEventDataTypedDict(TypedDict):
    action: str
    r"""Requested action description"""
    description: str
    r"""Human-readable permission description"""
    id: str
    r"""Permission request identifier"""
    session_id: str
    r"""Session identifier for the permission request"""
    tool_name: ToolNameTypedDict
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""
    type: str
    r"""Permission event type"""
    params: NotRequired[ParamsTypedDict]
    r"""Additional parameters for the permission request"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""
    path: NotRequired[str]
    r"""File path for permission request"""


class SSEPermissionEventData(BaseModel):
    action: str
    r"""Requested action description"""

    description: str
    r"""Human-readable permission description"""

    id: str
    r"""Permission request identifier"""

    session_id: Annotated[str, pydantic.Field(alias="sessionId")]
    r"""Session identifier for the permission request"""

    tool_name: Annotated[ToolName, pydantic.Field(alias="toolName")]
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""

    type: str
    r"""Permission event type"""

    params: Optional[Params] = None
    r"""Additional parameters for the permission request"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    path: Optional[str] = None
    r"""File path for permission request"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["params", "parentToolCallId", "path"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEPermissionEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEPermissionEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEPermissionEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEPermissionEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEPermissionEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEPermissionEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEToolExecutionCompleteEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEToolExecutionCompleteEventDataTypedDict(TypedDict):
    progress: str
    r"""Final execution progress description"""
    success: bool
    r"""Indicates if tool execution succeeded"""
    tool_call_id: str
    r"""Tool call identifier"""
    tool_name: ToolNameTypedDict
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""
    type: str
    r"""Tool execution complete event type"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSEToolExecutionCompleteEventData(BaseModel):
    progress: str
    r"""Final execution progress description"""

    success: bool
    r"""Indicates if tool execution succeeded"""

    tool_call_id: Annotated[str, pydantic.Field(alias="toolCallId")]
    r"""Tool call identifier"""

    tool_name: Annotated[ToolName, pydantic.Field(alias="toolName")]
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""

    type: str
    r"""Tool execution complete event type"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEToolExecutionCompleteEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEToolExecutionCompleteEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEToolExecutionCompleteEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEToolExecutionCompleteEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEToolExecutionCompleteEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEToolExecutionCompleteEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEToolExecutionStartEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEToolExecutionStartEventDataTypedDict(TypedDict):
    progress: str
    r"""Execution progress description"""
    tool_call_id: str
    r"""Tool call identifier"""
    tool_name: ToolNameTypedDict
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""
    type: str
    r"""Tool execution start event type"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSEToolExecutionStartEventData(BaseModel):
    progress: str
    r"""Execution progress description"""

    tool_call_id: Annotated[str, pydantic.Field(alias="toolCallId")]
    r"""Tool call identifier"""

    tool_name: Annotated[ToolName, pydantic.Field(alias="toolName")]
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""

    type: str
    r"""Tool execution start event type"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEToolExecutionStartEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEToolExecutionStartEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEToolExecutionStartEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEToolExecutionStartEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEToolExecutionStartEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEToolExecutionStartEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEToolUseParameterDeltaEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEToolUseParameterDeltaEventDataTypedDict(TypedDict):
    input: str
    r"""Partial JSON parameter delta - may not be parseable until complete"""
    tool_call_id: str
    r"""Tool call identifier for correlation"""
    type: str
    r"""Tool use parameter delta event type"""
    assistant_message_id: NotRequired[str]
    r"""ID of the assistant message this tool parameter delta belongs to"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSEToolUseParameterDeltaEventData(BaseModel):
    input: str
    r"""Partial JSON parameter delta - may not be parseable until complete"""

    tool_call_id: Annotated[str, pydantic.Field(alias="toolCallId")]
    r"""Tool call identifier for correlation"""

    type: str
    r"""Tool use parameter delta event type"""

    assistant_message_id: Annotated[
        Optional[str], pydantic.Field(alias="assistantMessageId")
    ] = None
    r"""ID of the assistant message this tool parameter delta belongs to"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["assistantMessageId", "parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEToolUseParameterDeltaEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEToolUseParameterDeltaEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEToolUseParameterDeltaEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEToolUseParameterDeltaEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEToolUseParameterDeltaEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEToolUseParameterDeltaEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEToolUseParameterStreamingCompleteEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEToolUseParameterStreamingCompleteEventDataTypedDict(TypedDict):
    id: str
    r"""Tool call identifier"""
    input: str
    r"""Complete JSON-encoded tool input parameters"""
    name: ToolNameTypedDict
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""
    type: str
    r"""Tool use parameter streaming complete event type"""
    assistant_message_id: NotRequired[str]
    r"""ID of the assistant message this tool belongs to"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSEToolUseParameterStreamingCompleteEventData(BaseModel):
    id: str
    r"""Tool call identifier"""

    input: str
    r"""Complete JSON-encoded tool input parameters"""

    name: ToolName
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""

    type: str
    r"""Tool use parameter streaming complete event type"""

    assistant_message_id: Annotated[
        Optional[str], pydantic.Field(alias="assistantMessageId")
    ] = None
    r"""ID of the assistant message this tool belongs to"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["assistantMessageId", "parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEToolUseParameterStreamingCompleteEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEToolUseParameterStreamingCompleteEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEToolUseParameterStreamingCompleteEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEToolUseParameterStreamingCompleteEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEToolUseParameterStreamingCompleteEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEToolUseParameterStreamingCompleteEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEToolUseStartEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEToolUseStartEventDataTypedDict(TypedDict):
    id: str
    r"""Tool call identifier"""
    name: ToolNameTypedDict
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""
    type: str
    r"""Tool use start event type"""
    assistant_message_id: NotRequired[str]
    r"""ID of the assistant message this tool belongs to"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSEToolUseStartEventData(BaseModel):
    id: str
    r"""Tool call identifier"""

    name: ToolName
    r"""Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern"""

    type: str
    r"""Tool use start event type"""

    assistant_message_id: Annotated[
        Optional[str], pydantic.Field(alias="assistantMessageId")
    ] = None
    r"""ID of the assistant message this tool belongs to"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["assistantMessageId", "parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEToolUseStartEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEToolUseStartEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEToolUseStartEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEToolUseStartEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEToolUseStartEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEToolUseStartEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEContentEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEContentEventDataTypedDict(TypedDict):
    content: str
    r"""Streaming content delta"""
    type: str
    r"""Content event type"""
    assistant_message_id: NotRequired[str]
    r"""ID of the assistant message this content belongs to"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSEContentEventData(BaseModel):
    content: str
    r"""Streaming content delta"""

    type: str
    r"""Content event type"""

    assistant_message_id: Annotated[
        Optional[str], pydantic.Field(alias="assistantMessageId")
    ] = None
    r"""ID of the assistant message this content belongs to"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["assistantMessageId", "parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEContentEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEContentEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEContentEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEContentEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEContentEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEContentEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEThinkingEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEThinkingEventDataTypedDict(TypedDict):
    content: str
    r"""Thinking or reasoning content"""
    type: str
    r"""Thinking event type"""
    assistant_message_id: NotRequired[str]
    r"""ID of the assistant message this thinking belongs to"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""


class SSEThinkingEventData(BaseModel):
    content: str
    r"""Thinking or reasoning content"""

    type: str
    r"""Thinking event type"""

    assistant_message_id: Annotated[
        Optional[str], pydantic.Field(alias="assistantMessageId")
    ] = None
    r"""ID of the assistant message this thinking belongs to"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["assistantMessageId", "parentToolCallId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEThinkingEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEThinkingEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEThinkingEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEThinkingEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEThinkingEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEThinkingEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSECompleteEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSECompleteEventDataTypedDict(TypedDict):
    done: bool
    r"""Indicates message processing completion"""
    type: str
    r"""Completion type"""
    content: NotRequired[str]
    r"""Final response content"""
    message_id: NotRequired[str]
    r"""Completed message identifier"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""
    reasoning: NotRequired[str]
    r"""Optional reasoning content"""
    reasoning_duration: NotRequired[int]
    r"""Duration of reasoning process in milliseconds"""


class SSECompleteEventData(BaseModel):
    done: bool
    r"""Indicates message processing completion"""

    type: str
    r"""Completion type"""

    content: Optional[str] = None
    r"""Final response content"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Completed message identifier"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    reasoning: Optional[str] = None
    r"""Optional reasoning content"""

    reasoning_duration: Annotated[
        Optional[int], pydantic.Field(alias="reasoningDuration")
    ] = None
    r"""Duration of reasoning process in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "content",
                "messageId",
                "parentToolCallId",
                "reasoning",
                "reasoningDuration",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSECompleteEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSECompleteEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSECompleteEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSECompleteEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSECompleteEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSECompleteEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEErrorEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEErrorEventDataTypedDict(TypedDict):
    error: str
    r"""Error message description"""
    attempt: NotRequired[int]
    r"""Current retry attempt number"""
    max_attempts: NotRequired[int]
    r"""Maximum number of retry attempts"""
    parent_tool_call_id: NotRequired[str]
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""
    retry_after: NotRequired[int]
    r"""Milliseconds to wait before retry"""
    type: NotRequired[str]
    r"""Error type classification"""


class SSEErrorEventData(BaseModel):
    error: str
    r"""Error message description"""

    attempt: Optional[int] = None
    r"""Current retry attempt number"""

    max_attempts: Annotated[Optional[int], pydantic.Field(alias="maxAttempts")] = None
    r"""Maximum number of retry attempts"""

    parent_tool_call_id: Annotated[
        Optional[str], pydantic.Field(alias="parentToolCallId")
    ] = None
    r"""ID of the parent tool call that spawned this subagent (for nested events)"""

    retry_after: Annotated[Optional[int], pydantic.Field(alias="retryAfter")] = None
    r"""Milliseconds to wait before retry"""

    type: Optional[str] = None
    r"""Error type classification"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["attempt", "maxAttempts", "parentToolCallId", "retryAfter", "type"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SSEErrorEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEErrorEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEErrorEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEErrorEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEErrorEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEErrorEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEHeartbeatEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEHeartbeatEventDataTypedDict(TypedDict):
    type: str
    r"""Heartbeat type"""


class SSEHeartbeatEventData(BaseModel):
    type: str
    r"""Heartbeat type"""


class SSEHeartbeatEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEHeartbeatEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEHeartbeatEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEHeartbeatEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEHeartbeatEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEHeartbeatEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEConnectedEventEvent = Literal[
    "connected",
    "heartbeat",
    "error",
    "complete",
    "thinking",
    "content",
    "tool_use_start",
    "tool_use_parameter_streaming_complete",
    "tool_use_parameter_delta",
    "tool_execution_start",
    "tool_execution_complete",
    "permission",
    "notification",
    "user_message_created",
    "session_created",
    "session_deleted",
]
r"""Event type identifier"""


class SSEConnectedEventDataTypedDict(TypedDict):
    session_id: str
    r"""Session identifier for the connected stream"""


class SSEConnectedEventData(BaseModel):
    session_id: Annotated[str, pydantic.Field(alias="sessionId")]
    r"""Session identifier for the connected stream"""


class SSEConnectedEventTypedDict(TypedDict):
    r"""Base SSE event with standard fields"""

    event: SSEConnectedEventEvent
    r"""Event type identifier"""
    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""
    data: SSEConnectedEventDataTypedDict
    retry: NotRequired[int]
    r"""Client retry interval in milliseconds"""


class SSEConnectedEvent(BaseModel):
    r"""Base SSE event with standard fields"""

    event: SSEConnectedEventEvent
    r"""Event type identifier"""

    id: str
    r"""Unique sequential event identifier for ordering and reconnection"""

    data: SSEConnectedEventData

    retry: Optional[int] = None
    r"""Client retry interval in milliseconds"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SSEEventStreamTypedDict = TypeAliasType(
    "SSEEventStreamTypedDict",
    Union[
        SSEConnectedEventTypedDict,
        SSEHeartbeatEventTypedDict,
        SSEErrorEventTypedDict,
        SSECompleteEventTypedDict,
        SSEThinkingEventTypedDict,
        SSEContentEventTypedDict,
        SSEToolUseStartEventTypedDict,
        SSEToolUseParameterStreamingCompleteEventTypedDict,
        SSEToolUseParameterDeltaEventTypedDict,
        SSEToolExecutionStartEventTypedDict,
        SSEToolExecutionCompleteEventTypedDict,
        SSEPermissionEventTypedDict,
        SSENotificationEventTypedDict,
        SSEUserMessageCreatedEventTypedDict,
        SSESessionCreatedEventTypedDict,
        SSESessionDeletedEventTypedDict,
    ],
)
r"""Server-Sent Event stream with discriminated event types"""


SSEEventStream = Annotated[
    Union[
        Annotated[SSECompleteEvent, Tag("complete")],
        Annotated[SSEConnectedEvent, Tag("connected")],
        Annotated[SSEContentEvent, Tag("content")],
        Annotated[SSEErrorEvent, Tag("error")],
        Annotated[SSEHeartbeatEvent, Tag("heartbeat")],
        Annotated[SSENotificationEvent, Tag("notification")],
        Annotated[SSEPermissionEvent, Tag("permission")],
        Annotated[SSESessionCreatedEvent, Tag("session_created")],
        Annotated[SSESessionDeletedEvent, Tag("session_deleted")],
        Annotated[SSEThinkingEvent, Tag("thinking")],
        Annotated[SSEToolExecutionCompleteEvent, Tag("tool_execution_complete")],
        Annotated[SSEToolExecutionStartEvent, Tag("tool_execution_start")],
        Annotated[SSEToolUseParameterDeltaEvent, Tag("tool_use_parameter_delta")],
        Annotated[
            SSEToolUseParameterStreamingCompleteEvent,
            Tag("tool_use_parameter_streaming_complete"),
        ],
        Annotated[SSEToolUseStartEvent, Tag("tool_use_start")],
        Annotated[SSEUserMessageCreatedEvent, Tag("user_message_created")],
    ],
    Discriminator(lambda m: get_discriminator(m, "event", "event")),
]
r"""Server-Sent Event stream with discriminated event types"""
